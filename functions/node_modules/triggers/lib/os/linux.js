// example: dbus-monitor "type='signal',sender='org.gnome.TypingMonitor',interface='org.gnome.TypingMonitor'"

var Emitter = require('events').EventEmitter;

var command = ['/usr/bin/dbus-monitor', '--system'];

const EVENTS = {
  network: {
    opts: { interface: 'org.freedesktop.NetworkManager' },
    events: {
      'StateChanged'       : ['network', 'state_changed']
    },
  },
/*
  // this is for HAL. the standard now is upower (below)
  power: {
    opts: { interface: 'org.freedesktop.PowerManagement' },
    events: {
      'OnBatteryChanged'   : ['battery', 'state_changed'],
      'LowBatteryChanged'  : ['battery', 'low_battery_changed']
    }
  }
*/
  power: {
    opts: { interface: 'org.freedesktop.UPower' },
    events: {
      'Changed'            : ['battery', 'state_changed']

      // this is not an event, but a property, so it won't work
      // 'OnLowBattery'       : ['battery', 'low_battery']
    }
  },
  notifications: {
    opts: { interface: 'org.freedesktop.Notifications' },
    events: {
      'Notify'             : ['notification', 'opened'],
      'NotificationClosed' : ['notification', 'closed'],
      'ActionInvoked'      : ['notification', 'clicked']
    }
  },
  sound: {
    // opts: { path: '/com/canonical/indicator/sound/service' },
    opts: { interface: 'com.canonical.indicator.sound' },
    events: {
      'SoundStateUpdate'   : ['sound', 'state_updated']
    }
  },
  media: {
    opts: { interface: "org.freedesktop.Hal.Manage" },
    events: {
       'DeviceAdded'       : ['media', 'inserted'],
       'DeviceRemoved'     : ['media', 'removed']
    }
  },
  device: {
    opts: {
      path: '/org/freedesktop/Hal/devices/computer_logicaldev_input',
      interface: 'org.freedesktop.Hal.Device'
    },
    events: {
      'ButtonPressed'       : ['device', 'power_button_pressed']
    }
  }
}

var argumentify = function(obj){
  var arr = [];
  for (var key in obj) {
    arr.push(key + '=' + obj[key] + '');
  }
  return arr.join(',');
};

var resolve_event = function(data, type){
  if (type != 'all')
    return EVENTS[type].events[data.member];

  for (var type in EVENTS) {
    if (EVENTS[type].events[data.member]) {
      if (matches_opts(data, EVENTS[type].opts))
        return EVENTS[type].events[data.member];
    }
  }
};

var parse_sender = function(line){
  var obj = {};

  line.split(/\s+/).forEach(function(arg){
    var split = arg.split('=');
    if (split[1])
      obj[split[0]] = split[1].replace(/;$/, '');
  });

  return obj;
};

var parse_args = function(lines){
  return lines.filter(function(l){
    return !l.trim().match(/^\[|\]|\(|\)$/) && !l.match(/array|dict|variant/);
  }).map(function(l) {
    // console.log('Line: ' + l);
    return l.trim().split(',')[0].replace(/([^\s]+)/, '').trim()
  });
};

var matches_opts = function(data, opts){
  var matches = true;

  for (var key in data) {
    if (opts[key] && opts[key] != data[key])
      matches = false;
  }
  return matches;
};

var matches_type = function(data, type){
  if (type == 'all')
    return true;
  else
    return matches_opts(data, EVENTS[type].opts);
};


var Watcher = function(main_emitter, child, type, emitter) {

  var self = this;
  this.emitter = emitter || new Emitter();

  var parse_data = function(data){

    data.toString().split('sender=').forEach(function(block) {

      var lines = block.trim().split('\n'),
          data  = parse_sender(lines.shift());

      if (Object.keys(data).length > 0 && matches_type(data, type)) {

        var event = resolve_event(data, type),
            args = parse_args(lines);

        if (!event)
          return; // emitter.emit(data.member, args);

        main_emitter.emit('event', event.join('_'), args);
        main_emitter.emit(event.join('_'), args);
        self.emitter.emit(event[1], args);
      }

    })
  }

  child.stdout.on('data', parse_data);

  this.stop = function(){
    child.stdout.removeListener('data', parse_data);
  }

}

exports.command = command;
exports.Watcher = Watcher;
exports.EVENTS  = EVENTS;

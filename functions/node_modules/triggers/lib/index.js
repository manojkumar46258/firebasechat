var os_name   = process.platform.replace('win32', 'windows').replace('darwin', 'mac'),
    os_module = require(require('path').join(__dirname, 'os', os_name));

var spawn   = require('child_process').spawn,
    Emitter = require('events').EventEmitter;

var child,
    stopped,
    returned,
    main_emitter,
    respawned = false,
    watchers  = {};

var debug = function(str) {
  if (process.env.DEBUG)
    console.log(str);
}

var respawn = function() {
  if (respawned) return;

  setTimeout(function() {
    // when loading one by one, we may trigger respawn() 
    // before the stopped flag is set to true, so we need
    // to check it out after this delay, to make sure we don't respawn after being stopped.
    if (stopped) return; 

    debug('Respawning!');
    for (var trigger in watchers) {
      var emitter = watchers[trigger].emitter;
      unwatch(trigger);
      watch(trigger, { respawn: true, emitter: emitter });
    }
    respawned = true;

  }, 100)
}

var watch = function(triggers, opts, cb) {
  if (!triggers)
    throw("Trigger name required. Otherwise try with 'all'.");

  debug('Watching triggers: ' + triggers);

  var cb = (typeof opts == 'function') ? opts : cb;
  stopped = false; // make sure done() returns the callback

  var timer,
      error,
      watcher,
      event_keys = Object.keys(os_module.EVENTS);

  var done = function(exit) {
    if (exit) child = null;
    if (stopped) return;

    if (exit) { // something went wrong
      if (returned) {
        if (opts && opts.respawn) respawn();
        return main_emitter.emit('killed');
      } else {
        error = new Error('Unable to start watcher command.');
      }
    }

    cb && cb(error, !error && watcher.emitter)

    respawned = false;
    returned  = true;
  };

  if (!child) {
    debug('Spawning child: ' + os_module.command);
    child = spawn(os_module.command[0], os_module.command.slice(1));
  }

  child.on('error', function(err) {
    if (err.code == 'ENOENT')
      err.message = 'ENOENT - Command not found: ' + os_module.command[0];

    // console.log('Got error: ' + err.toString());
    error = err;
  })

  child.on('exit', function(code) {
    if (timer) clearTimeout(timer);
    child = null;
    done(true);
  })

  var list = (typeof triggers == 'string') ? [triggers] : triggers;

  list.forEach(function(type){
    if (type != 'all' && event_keys.indexOf(type) == -1)
      throw('Unknown event type. Available: ' + event_keys.join(', '));

    if (watchers[type])
      throw('Already watching: ' + type);

    watcher = new os_module.Watcher(main_emitter, child, type, opts.emitter);
    watchers[type] = watcher;
  });

  timer = setTimeout(done, 100);

}

var unwatch = function(trigger) {
  // if there are no watchers, return
  if (Object.keys(watchers).length == 0)
    return;

  // find watcher and stop it
  var watcher = watchers[trigger];

  if (!watcher)
    return;

  watcher.stop();
  delete watchers[trigger];

  debug('Unwatched ' + trigger + '. Current: ' + Object.keys(watchers).length);

  // if no watchers are left, stop process
  if (child && Object.keys(watchers).length == 0) {
    debug('No more watchers, so killing child.');
    stopped = true;
    child.kill();
  }

}

module.exports = main_emitter = new Emitter();

module.exports.watch = watch;

module.exports.unwatch = unwatch;

module.exports.stop = function() {
  for (var trigger in watchers)
    module.exports.unwatch(trigger);
}
